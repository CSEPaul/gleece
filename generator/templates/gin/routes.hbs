/*
--
This file is automatically generated. Any manual changes to this file may be overwritten.
It includes routes and handlers by the Gleece API Routes Generator.
--
Authors: Haim Kastner & Yuval Pomerchik
Generated by: Gleece Routes Generator
Generated Date: {{{GenerationDate}}}
--
Usage:
Refer to the Gleece documentation for details on how to use the generated routes and handlers.
--
Repository: https://github.com/gopher-fleece/gleece
--
*/

package {{{PackageName}}}

{{> Imports}}

var validatorInstance *validator.Validate
var urlParamRegex = regexp.MustCompile(`\{([\w\d-_]+)\}`)

func getStatusCode(controller external.Controller, hasReturnValue bool, err error) int {
	if controller.GetStatus() != nil {
		return int(*controller.GetStatus())
	} 

	if err != nil {
		return http.StatusInternalServerError
	}

	if hasReturnValue {
		return http.StatusOK
	}

	return http.StatusNoContent
}

func bindAndValidateBody[TOutput any](ctx *gin.Context, contentType string, output *TOutput) error {
	var err error

	bodyBytes, err := io.ReadAll(ctx.Request.Body)
	if err != nil {
		return err
	}

	var deserializedOutput TOutput

	switch contentType {
	case "application/json":
		err = json.Unmarshal(bodyBytes, &deserializedOutput)
	default:
		return fmt.Errorf("content-type %s is not currently supported by the validation subsystem", contentType)
	}

	if err != nil {
		return err
	}

	if err = validatorInstance.Struct(&deserializedOutput); err != nil {
		return err
	}

	output = &deserializedOutput
	return nil
}

func toGinUrl(url string) string {
	return urlParamRegex.ReplaceAllString(url, ":$1")
}

func RegisterRoutes(engine *gin.Engine) {
	validatorInstance = validator.New()

{{#each CustomValidators}}
	validatorInstance.RegisterValidation("{{{ValidateTagName}}}", func(fl validator.FieldLevel) bool {
		return CustomValidatorPkg{{@index}}.{{{FunctionName}}}(fl)
	})
{{/each}}

{{#each Controllers}}
	// {{{Name}}}
	{{#each Routes}}
		engine.{{{HttpVerb}}}(toGinUrl("{{{../RestMetadata.Path}}}{{{RestMetadata.Path}}}"), func(ctx *gin.Context) {
			controller := {{{Name}}}Import.{{../Name}}{}
			controller.SetRequest(ctx)
			{{#each FuncParams}}
				{{> RequestArgsParsing}}
			{{/each}}

		{{#equal HasReturnValue true}}value, {{/equal}}opError := controller.{{{OperationId}}}({{#each FuncParams}}{{ToLowerCamel Name}}{{#unless @last}}, {{/unless}}{{/each}})

		{{> ReplyResponse}}
	})

	{{/each}}
{{/each}}
}